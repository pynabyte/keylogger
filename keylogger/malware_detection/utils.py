import os, magic, hashlib, pefile, json,joblib,pickle,array,math
from oletools.olevba import VBA_Parser

def get_imphash(path):
    try:
        pe = pefile.PE(path)
        return pe.get_imphash()
    except:
        return "[!] Err : Invalid PE header"
    
def get_file_hashes(path):
    md5 = hashlib.md5()
    sha1 = hashlib.sha1()
    sha256 = hashlib.sha256()
    with open(path,'rb') as f:
        chunk = f.read(4096)
        while len(chunk) > 0:
            md5.update(chunk)
            sha1.update(chunk)
            sha256.update(chunk)
            chunk = f.read(4096)
        return {'md5':md5.hexdigest(), 'sha1':sha1.hexdigest(), 'sha256':sha256.hexdigest()}

def get_files(path):
    if os.path.isdir(path):
        files = []
        for item in os.listdir(path):
            pth = os.path.join(path,item)
            if os.path.isfile(pth):
                files.append(pth)
        return files
    if os.path.isfile(path):
        return [path]

def analyze_doc(path):
    try:
        vb_parse = VBA_Parser(path)
        vb_parse.analyze_macros()
        return json.dumps(vb_parse.analysis_results, indent=2, default=str)
    except:
        return 'Not a VBA file'
    
def get_imports(path):
    try:
        pe = pefile.PE(path)
        pe.parse_data_directories()
        total_functions = 0
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            total_functions += len(entry.imports)
        return (len(pe.DIRECTORY_ENTRY_IMPORT), total_functions)
    except:
        return "[!] Err: Invalid PE"

def get_flags(section):
    flags = ""
    if section.Characteristics & 0x40000000:
        flags += "R"
    if section.Characteristics & 0x80000000:
        flags += "W"
    if section.Characteristics & 0x20000000:
        flags += "X"
    return flags

def analyze_sections(path):
    sections = []
    try:
        pe = pefile.PE(path)
        for section in pe.sections:
            section_name = section.Name.decode().rstrip("\x00")
            sections.append(get_flags(section))
        return sections
    except:
        return "[!] Err: Invalid PE"

def analyze_metrics(path):
    files = get_files(path)
    response = {}
    for file in files:
        print(file)
        hashes = get_file_hashes(file)
        response['file_summary'] = {
            'type': magic.from_file(file),
            'md5': hashes['md5'],
            'sha1': hashes['sha1'],
            'sha256': hashes['sha256'],
            'imphash': get_imphash(file)
        }
    if os.path.isfile(path):
        response['vba'] = analyze_doc(path)
    for file in files:
        response['imports'] = get_imports(file)
    for file in files:
        response['PE'] = analyze_sections(file)
    
    return response

def get_entropy(data):
    if len(data) == 0:
        return 0.0
    occurrences = array.array('L', [0] * 256)
    for x in data:
        occurrences[x if isinstance(x, int) else ord(x)] += 1

    entropy = 0
    for x in occurrences:
        if x:
            p_x = float(x) / len(data)
            entropy -= p_x * math.log(p_x, 2)

    return entropy

def get_resources(pe):
    resources = []
    if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
        try:
            for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                if hasattr(resource_type, 'directory'):
                    for resource_id in resource_type.directory.entries:
                        if hasattr(resource_id, 'directory'):
                            for resource_lang in resource_id.directory.entries:
                                data = pe.get_data(resource_lang.data.struct.OffsetToData,
                                                   resource_lang.data.struct.Size)
                                size = resource_lang.data.struct.Size
                                entropy = get_entropy(data)

                                resources.append([entropy, size])
        except Exception as e:
            return resources
    return resources


def get_version_info(pe):
    """Return version info's"""
    res = {}
    for fileinfo in pe.FileInfo:
        if fileinfo.Key == 'StringFileInfo':
            for st in fileinfo.StringTable:
                for entry in st.entries.items():
                    res[entry[0]] = entry[1]
        if fileinfo.Key == 'VarFileInfo':
            for var in fileinfo.Var:
                res[var.entry.items()[0][0]] = var.entry.items()[0][1]
    if hasattr(pe, 'VS_FIXEDFILEINFO'):
        res['flags'] = pe.VS_FIXEDFILEINFO.FileFlags
        res['os'] = pe.VS_FIXEDFILEINFO.FileOS
        res['type'] = pe.VS_FIXEDFILEINFO.FileType
        res['file_version'] = pe.VS_FIXEDFILEINFO.FileVersionLS
        res['product_version'] = pe.VS_FIXEDFILEINFO.ProductVersionLS
        res['signature'] = pe.VS_FIXEDFILEINFO.Signature
        res['struct_version'] = pe.VS_FIXEDFILEINFO.StrucVersion
    return res


def extract_info(file_path):
    res = {}
    try:
        pe = pefile.PE(file_path)
    except pefile.PEFormatError:
        return {}
    res['Machine'] = pe.FILE_HEADER.Machine
    res['SizeOfOptionalHeader'] = pe.FILE_HEADER.SizeOfOptionalHeader
    res['Characteristics'] = pe.FILE_HEADER.Characteristics
    res['MajorLinkerVersion'] = pe.OPTIONAL_HEADER.MajorLinkerVersion
    res['MinorLinkerVersion'] = pe.OPTIONAL_HEADER.MinorLinkerVersion
    res['SizeOfCode'] = pe.OPTIONAL_HEADER.SizeOfCode
    res['SizeOfInitializedData'] = pe.OPTIONAL_HEADER.SizeOfInitializedData
    res['SizeOfUninitializedData'] = pe.OPTIONAL_HEADER.SizeOfUninitializedData
    res['AddressOfEntryPoint'] = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    res['BaseOfCode'] = pe.OPTIONAL_HEADER.BaseOfCode
    try:
        res['BaseOfData'] = pe.OPTIONAL_HEADER.BaseOfData
    except AttributeError:
        res['BaseOfData'] = 0
    res['ImageBase'] = pe.OPTIONAL_HEADER.ImageBase
    res['SectionAlignment'] = pe.OPTIONAL_HEADER.SectionAlignment
    res['FileAlignment'] = pe.OPTIONAL_HEADER.FileAlignment
    res['MajorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
    res['MinorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MinorOperatingSystemVersion
    res['MajorImageVersion'] = pe.OPTIONAL_HEADER.MajorImageVersion
    res['MinorImageVersion'] = pe.OPTIONAL_HEADER.MinorImageVersion
    res['MajorSubsystemVersion'] = pe.OPTIONAL_HEADER.MajorSubsystemVersion
    res['MinorSubsystemVersion'] = pe.OPTIONAL_HEADER.MinorSubsystemVersion
    res['SizeOfImage'] = pe.OPTIONAL_HEADER.SizeOfImage
    res['SizeOfHeaders'] = pe.OPTIONAL_HEADER.SizeOfHeaders
    res['CheckSum'] = pe.OPTIONAL_HEADER.CheckSum
    res['Subsystem'] = pe.OPTIONAL_HEADER.Subsystem
    res['DllCharacteristics'] = pe.OPTIONAL_HEADER.DllCharacteristics
    res['SizeOfStackReserve'] = pe.OPTIONAL_HEADER.SizeOfStackReserve
    res['SizeOfStackCommit'] = pe.OPTIONAL_HEADER.SizeOfStackCommit
    res['SizeOfHeapReserve'] = pe.OPTIONAL_HEADER.SizeOfHeapReserve
    res['SizeOfHeapCommit'] = pe.OPTIONAL_HEADER.SizeOfHeapCommit
    res['LoaderFlags'] = pe.OPTIONAL_HEADER.LoaderFlags
    res['NumberOfRvaAndSizes'] = pe.OPTIONAL_HEADER.NumberOfRvaAndSizes

    # Sections
    res['SectionsNb'] = len(pe.sections)
    entropy = list(map(lambda x: x.get_entropy(), pe.sections))
    res['SectionsMeanEntropy'] = round(sum(entropy) / float(len(entropy)),3)
    res['SectionsMinEntropy'] = min(entropy)
    res['SectionsMaxEntropy'] = round(max(entropy),3)
    raw_sizes = list(map(lambda x: x.SizeOfRawData, pe.sections))
    res['SectionsMeanRawsize'] = round(sum(raw_sizes) / float(len(raw_sizes)),3)
    res['SectionsMinRawsize'] = min(raw_sizes)
    res['SectionsMaxRawsize'] = max(raw_sizes)
    virtual_sizes = list(map(lambda x: x.Misc_VirtualSize, pe.sections))
    res['SectionsMeanVirtualsize'] = sum(virtual_sizes) / float(len(virtual_sizes))
    res['SectionsMinVirtualsize'] = min(virtual_sizes)
    res['SectionMaxVirtualsize'] = max(virtual_sizes)

    # Imports
    try:
        res['ImportsNbDLL'] = len(pe.DIRECTORY_ENTRY_IMPORT)
        imports = sum([x.imports for x in pe.DIRECTORY_ENTRY_IMPORT], [])
        res['ImportsNb'] = len(imports)
        res['ImportsNbOrdinal'] = len(list(filter(lambda x: x.name is None, imports)))
    except AttributeError:
        res['ImportsNbDLL'] = 0
        res['ImportsNb'] = 0
        res['ImportsNbOrdinal'] = 0

    # Exports
    try:
        res['ExportNb'] = len(pe.DIRECTORY_ENTRY_EXPORT.symbols)
    except AttributeError:
        # No export
        res['ExportNb'] = 0

    # Resources
    resources = get_resources(pe)
    res['ResourcesNb'] = len(resources)
    if len(resources) > 0:
        entropy = list(map(lambda x: x[0], resources))
        res['ResourcesMeanEntropy'] = round(sum(entropy) / float(len(entropy)), 3)
        res['ResourcesMinEntropy'] = min(entropy)
        res['ResourcesMaxEntropy'] = round(max(entropy), 3)
        sizes = list(map(lambda x: x[1], resources))
        res['ResourcesMeanSize'] = round(sum(sizes) / float(len(sizes)), 3)
        res['ResourcesMinSize'] = min(sizes)
        res['ResourcesMaxSize'] = max(sizes)
    else:
        res['ResourcesNb'] = 0
        res['ResourcesMeanEntropy'] = 0
        res['ResourcesMinEntropy'] = 0
        res['ResourcesMaxEntropy'] = 0
        res['ResourcesMeanSize'] = 0
        res['ResourcesMinSize'] = 0
        res['ResourcesMaxSize'] = 0

    # Load configuration size
    try:
        res['LoadConfigurationSize'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.Size
    except AttributeError:
        res['LoadConfigurationSize'] = 0

    # Version configuration size
    try:
        version_info = get_version_info(pe)
        res['VersionInformationSize'] = len(version_info.keys())
    except AttributeError:
        res['VersionInformationSize'] = 0
    return res

def checkFile(file_path,base_directory):
    model = joblib.load(os.path.join(base_directory, 'malware_detection/model/model.pkl'))
    features = pickle.loads(open(os.path.join(base_directory, 'malware_detection/model/features.pkl'), 'rb').read())
    data = extract_info(file_path)
    if data != {}:
        pe_features = list(map(lambda x: data[x], features))
        res = model.predict([pe_features])[0]
        data['severity'] = round(model.predict_proba([pe_features])[0][0],3)
    else:
        res = 1
    if res:
        data['legitimate'] = "No Malware"
    else:
        data['legitimate'] = "Malware Detected"
    return data